#pragma version 10
intcblock 1 0 10000
bytecblock 0x151f7c75 0x 0x7c 0x686f6e 0x746f74616c42617463686573 0x63706e 0x746f74616c566572696669636174696f6e73 0x746f74616c5061796d656e7473 0x61646d696e 0x767273 0x626374 0x686f73 0x626173 0x6370686e 0x63706e6f 0x626667 0x626f63 0x626661 0x637067 0x637070 0x686f66 0x686f74 0x686f79 0x686361 0x636373 0x636363 0x636364 0x636374 0x636361 0x667262 0x667276 0x667266 0x667274 0x667263 0x667270 0x667275 0x707473 0x7066 0x7062 0x7061 0x7063 0x7074 0x63707473 0x626670 0x626361 0x637074 0x637068 0x687068 0x767263 0x767272 0x767276 0x767274 0x6277 0x00

// This TEAL was generated by TEALScript v0.107.2
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// assertBatchExists(batchAsaId: BatchAsaId): void
assertBatchExists:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:65
	// maxBatchId = this.totalBatches.exists ? this.totalBatches.value : 0
	txna Applications 0
	bytec 4 //  "totalBatches"
	app_global_get_ex
	swap
	pop
	bz *ternary0_false
	bytec 4 //  "totalBatches"
	app_global_get
	b *ternary0_end

*ternary0_false:
	intc 1 // 0

*ternary0_end:
	frame_bury 0 // maxBatchId: uint64

	// contracts/contractSupply/contract.algo.ts:66
	// assert(batchAsaId > 0 && batchAsaId <= maxBatchId, "Batch not found")
	frame_dig -1 // batchAsaId: BatchAsaId
	intc 1 // 0
	>
	dup
	bz *skip_and0
	frame_dig -1 // batchAsaId: BatchAsaId
	frame_dig 0 // maxBatchId: uint64
	<=
	&&

*skip_and0:
	// Batch not found
	assert
	retsub

// assertAdmin(): void
//
// Access control: only the admin (contract creator) can call write methods.
// Admin is set on createApplication and can be transferred via setAdmin.
assertAdmin:
	proto 0 0

	// contracts/contractSupply/contract.algo.ts:74
	// assert(
	//             this.admin.exists && this.txn.sender === this.admin.value,
	//             "Only admin can perform this action"
	//         )
	txna Applications 0
	bytec 8 //  "admin"
	app_global_get_ex
	swap
	pop
	dup
	bz *skip_and1
	txn Sender
	bytec 8 //  "admin"
	app_global_get
	==
	&&

*skip_and1:
	// Only admin can perform this action
	assert
	retsub

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	intc 0 // 1
	return

// createApplication(): void
//
// Called once when the application is created. Sets the deployer as admin.
createApplication:
	proto 0 0

	// contracts/contractSupply/contract.algo.ts:84
	// this.admin.value = this.txn.sender
	bytec 8 //  "admin"
	txn Sender
	app_global_put
	retsub

// setAdmin(address)void
*abi_route_setAdmin:
	// newAdmin: address
	txna ApplicationArgs 1
	dup
	len
	pushint 32
	==

	// argument 0 (newAdmin) for setAdmin must be a address
	assert

	// execute setAdmin(address)void
	callsub setAdmin
	intc 0 // 1
	return

// setAdmin(newAdmin: Address): void
//
// Transfer admin rights to a new address. Only current admin can call.
setAdmin:
	proto 1 0

	// contracts/contractSupply/contract.algo.ts:91
	// this.assertAdmin()
	callsub assertAdmin

	// contracts/contractSupply/contract.algo.ts:92
	// this.admin.value = newAdmin
	bytec 8 //  "admin"
	frame_dig -1 // newAdmin: Address
	app_global_put
	retsub

// assertVerificationExists(batchAsaId: BatchAsaId): void
assertVerificationExists:
	proto 1 0

	// *if0_condition
	// contracts/contractSupply/contract.algo.ts:96
	// !this.verificationResultBox(batchAsaId).exists
	bytec 9 //  "vrs"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_len
	swap
	pop
	!
	bz *if0_end

	// *if0_consequent
	// contracts/contractSupply/contract.algo.ts:97
	// assert(false, "Verification not found")
	intc 1 // 0

	// Verification not found
	assert

*if0_end:
	retsub

// assertCheckpointIndex(batchAsaId: BatchAsaId, index: uint64): void
assertCheckpointIndex:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:102
	// assert(index > 0, "Checkpoint index must be > 0")
	frame_dig -2 // index: uint64
	intc 1 // 0
	>

	// Checkpoint index must be > 0
	assert

	// *if1_condition
	// contracts/contractSupply/contract.algo.ts:103
	// !this.checkpointCountBox(batchAsaId).exists
	bytec 5 //  "cpn"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_len
	swap
	pop
	!
	bz *if1_end

	// *if1_consequent
	// contracts/contractSupply/contract.algo.ts:103
	// assert(false, "Checkpoint not found")
	intc 1 // 0

	// Checkpoint not found
	assert

*if1_end:
	// contracts/contractSupply/contract.algo.ts:104
	// count = this.checkpointCountBox(batchAsaId).value
	bytec 5 //  "cpn"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.checkpointCountBox(batchAsaId).value
	assert
	btoi
	frame_bury 0 // count: uint64

	// contracts/contractSupply/contract.algo.ts:105
	// assert(index <= count, "Checkpoint not found")
	frame_dig -2 // index: uint64
	frame_dig 0 // count: uint64
	<=

	// Checkpoint not found
	assert
	retsub

// assertHandoffIndex(batchAsaId: BatchAsaId, index: uint64): void
assertHandoffIndex:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:109
	// assert(index > 0, "Handoff index must be > 0")
	frame_dig -2 // index: uint64
	intc 1 // 0
	>

	// Handoff index must be > 0
	assert

	// *if2_condition
	// contracts/contractSupply/contract.algo.ts:110
	// !this.handoffCountBox(batchAsaId).exists
	bytec 3 //  "hon"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_len
	swap
	pop
	!
	bz *if2_end

	// *if2_consequent
	// contracts/contractSupply/contract.algo.ts:110
	// assert(false, "Handoff not found")
	intc 1 // 0

	// Handoff not found
	assert

*if2_end:
	// contracts/contractSupply/contract.algo.ts:111
	// count = this.handoffCountBox(batchAsaId).value
	bytec 3 //  "hon"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.handoffCountBox(batchAsaId).value
	assert
	btoi
	frame_bury 0 // count: uint64

	// contracts/contractSupply/contract.algo.ts:112
	// assert(index <= count, "Handoff not found")
	frame_dig -2 // index: uint64
	frame_dig 0 // count: uint64
	<=

	// Handoff not found
	assert
	retsub

// nextPaymentId(): uint64
nextPaymentId:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// contracts/contractSupply/contract.algo.ts:116
	// current = this.totalPayments.exists ? this.totalPayments.value : 0
	txna Applications 0
	bytec 7 //  "totalPayments"
	app_global_get_ex
	swap
	pop
	bz *ternary1_false
	bytec 7 //  "totalPayments"
	app_global_get
	b *ternary1_end

*ternary1_false:
	intc 1 // 0

*ternary1_end:
	frame_bury 0 // current: uint64

	// contracts/contractSupply/contract.algo.ts:117
	// nextId = current + 1
	frame_dig 0 // current: uint64
	intc 0 // 1
	+
	frame_bury 1 // nextId: uint64

	// contracts/contractSupply/contract.algo.ts:118
	// this.totalPayments.value = nextId
	bytec 7 //  "totalPayments"
	frame_dig 1 // nextId: uint64
	app_global_put

	// contracts/contractSupply/contract.algo.ts:119
	// return nextId;
	frame_dig 1 // nextId: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// createBatch(string,uint64,string,string,string,string,uint64)uint64
*abi_route_createBatch:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// createdAt: uint64
	txna ApplicationArgs 7
	btoi

	// farmerAddr: string
	txna ApplicationArgs 6
	extract 2 0

	// organicCertId: string
	txna ApplicationArgs 5
	extract 2 0

	// farmingPractices: string
	txna ApplicationArgs 4
	extract 2 0

	// farmGps: string
	txna ApplicationArgs 3
	extract 2 0

	// weight: uint64
	txna ApplicationArgs 2
	btoi

	// cropType: string
	txna ApplicationArgs 1
	extract 2 0

	// execute createBatch(string,uint64,string,string,string,string,uint64)uint64
	callsub createBatch
	itob
	concat
	log
	intc 0 // 1
	return

// createBatch(cropType: string, weight: uint64, farmGps: string, farmingPractices: string, organicCertId: string, farmerAddr: string, createdAt: uint64): BatchAsaId
createBatch:
	proto 7 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// contracts/contractSupply/contract.algo.ts:132
	// this.assertAdmin()
	callsub assertAdmin

	// contracts/contractSupply/contract.algo.ts:133
	// current = this.totalBatches.exists ? this.totalBatches.value : 0
	txna Applications 0
	bytec 4 //  "totalBatches"
	app_global_get_ex
	swap
	pop
	bz *ternary2_false
	bytec 4 //  "totalBatches"
	app_global_get
	b *ternary2_end

*ternary2_false:
	intc 1 // 0

*ternary2_end:
	frame_bury 0 // current: uint64

	// contracts/contractSupply/contract.algo.ts:134
	// nextId = current + 1
	frame_dig 0 // current: uint64
	intc 0 // 1
	+
	frame_bury 1 // nextId: uint64

	// contracts/contractSupply/contract.algo.ts:135
	// this.totalBatches.value = nextId
	bytec 4 //  "totalBatches"
	frame_dig 1 // nextId: uint64
	app_global_put

	// contracts/contractSupply/contract.algo.ts:136
	// this.batchCropTypeBox(nextId).value = cropType
	bytec 10 //  "bct"
	frame_dig 1 // nextId: uint64
	itob
	concat
	dup
	box_del
	pop
	frame_dig -1 // cropType: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:137
	// this.batchWeightBox(nextId).value = weight
	bytec 52 //  "bw"
	frame_dig 1 // nextId: uint64
	itob
	concat
	frame_dig -2 // weight: uint64
	itob
	box_put

	// contracts/contractSupply/contract.algo.ts:138
	// this.batchFarmGpsBox(nextId).value = farmGps
	bytec 15 //  "bfg"
	frame_dig 1 // nextId: uint64
	itob
	concat
	dup
	box_del
	pop
	frame_dig -3 // farmGps: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:139
	// this.batchFarmingPracticesBox(nextId).value = farmingPractices
	bytec 43 //  "bfp"
	frame_dig 1 // nextId: uint64
	itob
	concat
	dup
	box_del
	pop
	frame_dig -4 // farmingPractices: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:140
	// this.batchOrganicCertIdBox(nextId).value = organicCertId
	bytec 16 //  "boc"
	frame_dig 1 // nextId: uint64
	itob
	concat
	dup
	box_del
	pop
	frame_dig -5 // organicCertId: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:141
	// this.batchFarmerAddrBox(nextId).value = farmerAddr
	bytec 17 //  "bfa"
	frame_dig 1 // nextId: uint64
	itob
	concat
	dup
	box_del
	pop
	frame_dig -6 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:142
	// this.batchCreatedAtBox(nextId).value = createdAt
	bytec 44 //  "bca"
	frame_dig 1 // nextId: uint64
	itob
	concat
	frame_dig -7 // createdAt: uint64
	itob
	box_put

	// contracts/contractSupply/contract.algo.ts:143
	// return nextId;
	frame_dig 1 // nextId: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// logCheckpoint(uint64,string,string,uint64,uint64,string,string,string,uint64)void
*abi_route_logCheckpoint:
	// checkpointTimestamp: uint64
	txna ApplicationArgs 9
	btoi

	// photoHash: string
	txna ApplicationArgs 8
	extract 2 0

	// notes: string
	txna ApplicationArgs 7
	extract 2 0

	// handlerType: string
	txna ApplicationArgs 6
	extract 2 0

	// humidity: uint64
	txna ApplicationArgs 5
	btoi

	// temperature: uint64
	txna ApplicationArgs 4
	btoi

	// gpsLng: string
	txna ApplicationArgs 3
	extract 2 0

	// gpsLat: string
	txna ApplicationArgs 2
	extract 2 0

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute logCheckpoint(uint64,string,string,uint64,uint64,string,string,string,uint64)void
	callsub logCheckpoint
	intc 0 // 1
	return

// logCheckpoint(batchAsaId: BatchAsaId, gpsLat: string, gpsLng: string, temperature: uint64, humidity: uint64, handlerType: string, notes: string, photoHash: string, checkpointTimestamp: uint64): void
logCheckpoint:
	proto 9 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// contracts/contractSupply/contract.algo.ts:158
	// this.assertAdmin()
	callsub assertAdmin

	// contracts/contractSupply/contract.algo.ts:159
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:161
	// current = this.checkpointCountBox(batchAsaId).exists
	//             ? this.checkpointCountBox(batchAsaId).value
	//             : 0
	bytec 5 //  "cpn"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_len
	swap
	pop
	bz *ternary3_false
	bytec 5 //  "cpn"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.checkpointCountBox(batchAsaId).value
	assert
	btoi
	b *ternary3_end

*ternary3_false:
	intc 1 // 0

*ternary3_end:
	frame_bury 0 // current: uint64

	// contracts/contractSupply/contract.algo.ts:164
	// nextIndex = current + 1
	frame_dig 0 // current: uint64
	intc 0 // 1
	+
	frame_bury 1 // nextIndex: uint64

	// contracts/contractSupply/contract.algo.ts:165
	// this.checkpointCountBox(batchAsaId).value = nextIndex
	bytec 5 //  "cpn"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	frame_dig 1 // nextIndex: uint64
	itob
	box_put

	// contracts/contractSupply/contract.algo.ts:167
	// pk = batchAsaId * 10000 + nextIndex
	frame_dig -1 // batchAsaId: BatchAsaId
	intc 2 // 10000
	*
	frame_dig 1 // nextIndex: uint64
	+
	frame_bury 2 // pk: uint64

	// contracts/contractSupply/contract.algo.ts:168
	// this.checkpointGpsBox(pk).value = gpsLat + "|" + gpsLng
	bytec 18 //  "cpg"
	frame_dig 2 // pk: uint64
	itob
	concat
	dup
	box_del
	pop
	frame_dig -2 // gpsLat: string
	bytec 2 //  "|"
	concat
	frame_dig -3 // gpsLng: string
	concat
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:169
	// this.checkpointTemperatureBox(pk).value = temperature
	bytec 45 //  "cpt"
	frame_dig 2 // pk: uint64
	itob
	concat
	frame_dig -4 // temperature: uint64
	itob
	box_put

	// contracts/contractSupply/contract.algo.ts:170
	// this.checkpointHumidityBox(pk).value = humidity
	bytec 46 //  "cph"
	frame_dig 2 // pk: uint64
	itob
	concat
	frame_dig -5 // humidity: uint64
	itob
	box_put

	// contracts/contractSupply/contract.algo.ts:171
	// this.checkpointHandlerTypeBox(pk).value = handlerType
	bytec 13 //  "cphn"
	frame_dig 2 // pk: uint64
	itob
	concat
	dup
	box_del
	pop
	frame_dig -6 // handlerType: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:172
	// this.checkpointNotesBox(pk).value = notes
	bytec 14 //  "cpno"
	frame_dig 2 // pk: uint64
	itob
	concat
	dup
	box_del
	pop
	frame_dig -7 // notes: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:173
	// this.checkpointPhotoHashBox(pk).value = photoHash
	bytec 19 //  "cpp"
	frame_dig 2 // pk: uint64
	itob
	concat
	dup
	box_del
	pop
	frame_dig -8 // photoHash: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:174
	// this.checkpointTimestampBox(pk).value = checkpointTimestamp
	bytec 42 //  "cpts"
	frame_dig 2 // pk: uint64
	itob
	concat
	frame_dig -9 // checkpointTimestamp: uint64
	itob
	box_put
	retsub

// initiateHandoff(uint64,string,string,string,string)void
*abi_route_initiateHandoff:
	// handoffPhotoHashes: string
	txna ApplicationArgs 5
	extract 2 0

	// handoffType: string
	txna ApplicationArgs 4
	extract 2 0

	// toAddr: string
	txna ApplicationArgs 3
	extract 2 0

	// fromAddr: string
	txna ApplicationArgs 2
	extract 2 0

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute initiateHandoff(uint64,string,string,string,string)void
	callsub initiateHandoff
	intc 0 // 1
	return

// initiateHandoff(batchAsaId: BatchAsaId, fromAddr: string, toAddr: string, handoffType: string, handoffPhotoHashes: string): void
initiateHandoff:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dupn 2

	// contracts/contractSupply/contract.algo.ts:185
	// this.assertAdmin()
	callsub assertAdmin

	// contracts/contractSupply/contract.algo.ts:186
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:188
	// current = this.handoffCountBox(batchAsaId).exists
	//             ? this.handoffCountBox(batchAsaId).value
	//             : 0
	bytec 3 //  "hon"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_len
	swap
	pop
	bz *ternary4_false
	bytec 3 //  "hon"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.handoffCountBox(batchAsaId).value
	assert
	btoi
	b *ternary4_end

*ternary4_false:
	intc 1 // 0

*ternary4_end:
	frame_bury 0 // current: uint64

	// contracts/contractSupply/contract.algo.ts:191
	// nextIndex = current + 1
	frame_dig 0 // current: uint64
	intc 0 // 1
	+
	frame_bury 1 // nextIndex: uint64

	// contracts/contractSupply/contract.algo.ts:192
	// this.handoffCountBox(batchAsaId).value = nextIndex
	bytec 3 //  "hon"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	frame_dig 1 // nextIndex: uint64
	itob
	box_put

	// contracts/contractSupply/contract.algo.ts:194
	// pk = batchAsaId * 10000 + nextIndex
	frame_dig -1 // batchAsaId: BatchAsaId
	intc 2 // 10000
	*
	frame_dig 1 // nextIndex: uint64
	+
	frame_bury 2 // pk: uint64

	// contracts/contractSupply/contract.algo.ts:195
	// this.handoffFromAddrBox(pk).value = fromAddr
	bytec 20 //  "hof"
	frame_dig 2 // pk: uint64
	itob
	concat
	dup
	box_del
	pop
	frame_dig -2 // fromAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:196
	// this.handoffToAddrBox(pk).value = toAddr
	bytec 21 //  "hot"
	frame_dig 2 // pk: uint64
	itob
	concat
	dup
	box_del
	pop
	frame_dig -3 // toAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:197
	// this.handoffTypeBox(pk).value = handoffType
	bytec 22 //  "hoy"
	frame_dig 2 // pk: uint64
	itob
	concat
	dup
	box_del
	pop
	frame_dig -4 // handoffType: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:198
	// this.handoffStatusBox(pk).value = "pending"
	bytec 11 //  "hos"
	frame_dig 2 // pk: uint64
	itob
	concat
	dup
	box_del
	pop
	pushbytes 0x000770656e64696e67
	box_put

	// contracts/contractSupply/contract.algo.ts:199
	// this.handoffConfirmedAtBox(pk).value = 0
	bytec 23 //  "hca"
	frame_dig 2 // pk: uint64
	itob
	concat
	pushbytes 0x0000000000000000
	box_put

	// contracts/contractSupply/contract.algo.ts:200
	// this.handoffPhotoHashesBox(pk).value = handoffPhotoHashes
	bytec 47 //  "hph"
	frame_dig 2 // pk: uint64
	itob
	concat
	dup
	box_del
	pop
	frame_dig -5 // handoffPhotoHashes: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put
	retsub

// confirmHandoff(uint64,uint64,uint64)void
*abi_route_confirmHandoff:
	// confirmedAt: uint64
	txna ApplicationArgs 3
	btoi

	// handoffIndex: uint64
	txna ApplicationArgs 2
	btoi

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute confirmHandoff(uint64,uint64,uint64)void
	callsub confirmHandoff
	intc 0 // 1
	return

// confirmHandoff(batchAsaId: BatchAsaId, handoffIndex: uint64, confirmedAt: uint64): void
confirmHandoff:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:206
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:207
	// this.assertHandoffIndex(batchAsaId, handoffIndex)
	frame_dig -2 // handoffIndex: uint64
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertHandoffIndex

	// contracts/contractSupply/contract.algo.ts:208
	// pk = batchAsaId * 10000 + handoffIndex
	frame_dig -1 // batchAsaId: BatchAsaId
	intc 2 // 10000
	*
	frame_dig -2 // handoffIndex: uint64
	+
	frame_bury 0 // pk: uint64

	// contracts/contractSupply/contract.algo.ts:209
	// this.handoffStatusBox(pk).value = "confirmed"
	bytec 11 //  "hos"
	frame_dig 0 // pk: uint64
	itob
	concat
	dup
	box_del
	pop
	pushbytes 0x0009636f6e6669726d6564
	box_put

	// contracts/contractSupply/contract.algo.ts:210
	// this.handoffConfirmedAtBox(pk).value = confirmedAt
	bytec 23 //  "hca"
	frame_dig 0 // pk: uint64
	itob
	concat
	frame_dig -3 // confirmedAt: uint64
	itob
	box_put
	retsub

// mintBatchAsa(uint64,byte[])uint64
*abi_route_mintBatchAsa:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// metadataHash: byte[]
	txna ApplicationArgs 2
	extract 2 0

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute mintBatchAsa(uint64,byte[])uint64
	callsub mintBatchAsa
	itob
	concat
	log
	intc 0 // 1
	return

// mintBatchAsa(batchAsaId: BatchAsaId, metadataHash: bytes): uint64
mintBatchAsa:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// contracts/contractSupply/contract.algo.ts:214
	// this.assertAdmin()
	callsub assertAdmin

	// contracts/contractSupply/contract.algo.ts:215
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:216
	// assert(!this.batchAsaIdBox(batchAsaId).exists, "ASA already minted")
	bytec 12 //  "bas"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_len
	swap
	pop
	!

	// ASA already minted
	assert

	// contracts/contractSupply/contract.algo.ts:217
	// assetId = sendAssetCreation({
	//             fee: globals.minTxnFee,
	//             configAssetTotal: 1,
	//             configAssetDecimals: 0,
	//             configAssetName: "CHAINVERIFY-BATCH",
	//             configAssetUnitName: "CVBATCH",
	//             configAssetManager: globals.currentApplicationAddress,
	//             configAssetReserve: globals.currentApplicationAddress,
	//             configAssetFreeze: globals.currentApplicationAddress,
	//             configAssetClawback: globals.currentApplicationAddress,
	//             configAssetMetadataHash: metadataHash,
	//         })
	itxn_begin
	pushint 3 // acfg
	itxn_field TypeEnum

	// contracts/contractSupply/contract.algo.ts:218
	// fee: globals.minTxnFee
	global MinTxnFee
	itxn_field Fee

	// contracts/contractSupply/contract.algo.ts:219
	// configAssetTotal: 1
	intc 0 // 1
	itxn_field ConfigAssetTotal

	// contracts/contractSupply/contract.algo.ts:220
	// configAssetDecimals: 0
	intc 1 // 0
	itxn_field ConfigAssetDecimals

	// contracts/contractSupply/contract.algo.ts:221
	// configAssetName: "CHAINVERIFY-BATCH"
	pushbytes 0x434841494e5645524946592d4241544348 // "CHAINVERIFY-BATCH"
	itxn_field ConfigAssetName

	// contracts/contractSupply/contract.algo.ts:222
	// configAssetUnitName: "CVBATCH"
	pushbytes 0x43564241544348 // "CVBATCH"
	itxn_field ConfigAssetUnitName

	// contracts/contractSupply/contract.algo.ts:223
	// configAssetManager: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field ConfigAssetManager

	// contracts/contractSupply/contract.algo.ts:224
	// configAssetReserve: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field ConfigAssetReserve

	// contracts/contractSupply/contract.algo.ts:225
	// configAssetFreeze: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field ConfigAssetFreeze

	// contracts/contractSupply/contract.algo.ts:226
	// configAssetClawback: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field ConfigAssetClawback

	// contracts/contractSupply/contract.algo.ts:227
	// configAssetMetadataHash: metadataHash
	frame_dig -2 // metadataHash: bytes
	itxn_field ConfigAssetMetadataHash

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID
	frame_bury 0 // assetId: uint64

	// contracts/contractSupply/contract.algo.ts:229
	// assetIndex = assetId.id
	frame_dig 0 // assetId: uint64
	frame_bury 1 // assetIndex: uint64

	// contracts/contractSupply/contract.algo.ts:230
	// this.batchAsaIdBox(batchAsaId).value = assetIndex
	bytec 12 //  "bas"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	frame_dig 1 // assetIndex: uint64
	itob
	box_put

	// contracts/contractSupply/contract.algo.ts:231
	// return assetIndex;
	frame_dig 1 // assetIndex: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// storeVerification(uint64,string,uint64,string,string)void
*abi_route_storeVerification:
	// verifierAddr: string
	txna ApplicationArgs 5
	extract 2 0

	// reason: string
	txna ApplicationArgs 4
	extract 2 0

	// confidence: uint64
	txna ApplicationArgs 3
	btoi

	// result: string
	txna ApplicationArgs 2
	extract 2 0

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute storeVerification(uint64,string,uint64,string,string)void
	callsub storeVerification
	intc 0 // 1
	return

// storeVerification(batchAsaId: BatchAsaId, result: VerificationResult, confidence: uint64, reason: string, verifierAddr: string): void
storeVerification:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x
	dup

	// contracts/contractSupply/contract.algo.ts:242
	// this.assertAdmin()
	callsub assertAdmin

	// contracts/contractSupply/contract.algo.ts:243
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:245
	// existed = this.verificationResultBox(batchAsaId).exists
	bytec 9 //  "vrs"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_len
	swap
	pop
	frame_bury 0 // existed: bool

	// contracts/contractSupply/contract.algo.ts:246
	// this.verificationResultBox(batchAsaId).value = result
	bytec 9 //  "vrs"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	dup
	box_del
	pop
	frame_dig -2 // result: VerificationResult
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:247
	// this.verificationConfidenceBox(batchAsaId).value = confidence
	bytec 48 //  "vrc"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	frame_dig -3 // confidence: uint64
	itob
	box_put

	// contracts/contractSupply/contract.algo.ts:248
	// this.verificationReasonBox(batchAsaId).value = reason
	bytec 49 //  "vrr"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	dup
	box_del
	pop
	frame_dig -4 // reason: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:249
	// this.verificationVerifierAddrBox(batchAsaId).value = verifierAddr
	bytec 50 //  "vrv"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	dup
	box_del
	pop
	frame_dig -5 // verifierAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:250
	// this.verificationTimestampBox(batchAsaId).value = globals.latestTimestamp
	bytec 51 //  "vrt"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	global LatestTimestamp
	itob
	box_put

	// *if3_condition
	// contracts/contractSupply/contract.algo.ts:252
	// !existed
	frame_dig 0 // existed: bool
	!
	bz *if3_end

	// *if3_consequent
	// contracts/contractSupply/contract.algo.ts:253
	// current = this.totalVerifications.exists ? this.totalVerifications.value : 0
	txna Applications 0
	bytec 6 //  "totalVerifications"
	app_global_get_ex
	swap
	pop
	bz *ternary5_false
	bytec 6 //  "totalVerifications"
	app_global_get
	b *ternary5_end

*ternary5_false:
	intc 1 // 0

*ternary5_end:
	frame_bury 1 // current: uint64

	// contracts/contractSupply/contract.algo.ts:254
	// this.totalVerifications.value = current + 1
	bytec 6 //  "totalVerifications"
	frame_dig 1 // current: uint64
	intc 0 // 1
	+
	app_global_put

*if3_end:
	retsub

// updateCarbonScore(uint64,uint64,uint64,uint64,string,uint64)void
*abi_route_updateCarbonScore:
	// calculatedAt: uint64
	txna ApplicationArgs 6
	btoi

	// transportMethod: string
	txna ApplicationArgs 5
	extract 2 0

	// distance: uint64
	txna ApplicationArgs 4
	btoi

	// creditsEarned: uint64
	txna ApplicationArgs 3
	btoi

	// score: uint64
	txna ApplicationArgs 2
	btoi

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateCarbonScore(uint64,uint64,uint64,uint64,string,uint64)void
	callsub updateCarbonScore
	intc 0 // 1
	return

// updateCarbonScore(batchAsaId: BatchAsaId, score: uint64, creditsEarned: uint64, distance: uint64, transportMethod: string, calculatedAt: uint64): void
updateCarbonScore:
	proto 6 0

	// contracts/contractSupply/contract.algo.ts:267
	// this.assertAdmin()
	callsub assertAdmin

	// contracts/contractSupply/contract.algo.ts:268
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:269
	// this.carbonScoreBox(batchAsaId).value = score
	bytec 24 //  "ccs"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	frame_dig -2 // score: uint64
	itob
	box_put

	// contracts/contractSupply/contract.algo.ts:270
	// this.carbonCreditsBox(batchAsaId).value = creditsEarned
	bytec 25 //  "ccc"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	frame_dig -3 // creditsEarned: uint64
	itob
	box_put

	// contracts/contractSupply/contract.algo.ts:271
	// this.carbonDistanceBox(batchAsaId).value = distance
	bytec 26 //  "ccd"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	frame_dig -4 // distance: uint64
	itob
	box_put

	// contracts/contractSupply/contract.algo.ts:272
	// this.carbonTransportBox(batchAsaId).value = transportMethod
	bytec 27 //  "cct"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	dup
	box_del
	pop
	frame_dig -5 // transportMethod: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:273
	// this.carbonCalculatedAtBox(batchAsaId).value = calculatedAt
	bytec 28 //  "cca"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	frame_dig -6 // calculatedAt: uint64
	itob
	box_put
	retsub

// updateFarmerReputation(string,uint64,uint64,uint64,string,uint64,uint64,uint64)void
*abi_route_updateFarmerReputation:
	// lastUpdated: uint64
	txna ApplicationArgs 8
	btoi

	// totalPaymentsReceived: uint64
	txna ApplicationArgs 7
	btoi

	// carbonCreditsTotal: uint64
	txna ApplicationArgs 6
	btoi

	// tier: string
	txna ApplicationArgs 5
	extract 2 0

	// flaggedCount: uint64
	txna ApplicationArgs 4
	btoi

	// verifiedCount: uint64
	txna ApplicationArgs 3
	btoi

	// totalBatches: uint64
	txna ApplicationArgs 2
	btoi

	// farmerAddr: string
	txna ApplicationArgs 1
	extract 2 0

	// execute updateFarmerReputation(string,uint64,uint64,uint64,string,uint64,uint64,uint64)void
	callsub updateFarmerReputation
	intc 0 // 1
	return

// updateFarmerReputation(farmerAddr: string, totalBatches: uint64, verifiedCount: uint64, flaggedCount: uint64, tier: string, carbonCreditsTotal: uint64, totalPaymentsReceived: uint64, lastUpdated: uint64): void
updateFarmerReputation:
	proto 8 0

	// contracts/contractSupply/contract.algo.ts:287
	// this.assertAdmin()
	callsub assertAdmin

	// contracts/contractSupply/contract.algo.ts:288
	// this.farmerTotalBatchesBox(farmerAddr).value = totalBatches
	bytec 29 //  "frb"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	frame_dig -2 // totalBatches: uint64
	itob
	box_put

	// contracts/contractSupply/contract.algo.ts:289
	// this.farmerVerifiedCountBox(farmerAddr).value = verifiedCount
	bytec 30 //  "frv"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	frame_dig -3 // verifiedCount: uint64
	itob
	box_put

	// contracts/contractSupply/contract.algo.ts:290
	// this.farmerFlaggedCountBox(farmerAddr).value = flaggedCount
	bytec 31 //  "frf"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	frame_dig -4 // flaggedCount: uint64
	itob
	box_put

	// contracts/contractSupply/contract.algo.ts:291
	// this.farmerTierBox(farmerAddr).value = tier
	bytec 32 //  "frt"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	dup
	box_del
	pop
	frame_dig -5 // tier: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:292
	// this.farmerCarbonCreditsBox(farmerAddr).value = carbonCreditsTotal
	bytec 33 //  "frc"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	frame_dig -6 // carbonCreditsTotal: uint64
	itob
	box_put

	// contracts/contractSupply/contract.algo.ts:293
	// this.farmerPaymentsTotalBox(farmerAddr).value = totalPaymentsReceived
	bytec 34 //  "frp"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	frame_dig -7 // totalPaymentsReceived: uint64
	itob
	box_put

	// contracts/contractSupply/contract.algo.ts:294
	// this.farmerLastUpdatedBox(farmerAddr).value = lastUpdated
	bytec 35 //  "fru"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	frame_dig -8 // lastUpdated: uint64
	itob
	box_put
	retsub

// recordFarmerPayment(string,uint64,uint64,string,string,uint64)void
*abi_route_recordFarmerPayment:
	// timestamp: uint64
	txna ApplicationArgs 6
	btoi

	// txId: string
	txna ApplicationArgs 5
	extract 2 0

	// currency: string
	txna ApplicationArgs 4
	extract 2 0

	// amount: uint64
	txna ApplicationArgs 3
	btoi

	// batchAsaId: uint64
	txna ApplicationArgs 2
	btoi

	// farmerAddr: string
	txna ApplicationArgs 1
	extract 2 0

	// execute recordFarmerPayment(string,uint64,uint64,string,string,uint64)void
	callsub recordFarmerPayment
	intc 0 // 1
	return

// recordFarmerPayment(farmerAddr: string, batchAsaId: uint64, amount: uint64, currency: string, txId: string, timestamp: uint64): void
recordFarmerPayment:
	proto 6 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:305
	// this.assertAdmin()
	callsub assertAdmin

	// contracts/contractSupply/contract.algo.ts:306
	// paymentId = this.nextPaymentId()
	callsub nextPaymentId
	frame_bury 0 // paymentId: uint64

	// contracts/contractSupply/contract.algo.ts:307
	// this.paymentFarmerAddrBox(paymentId).value = farmerAddr
	bytec 37 //  "pf"
	frame_dig 0 // paymentId: uint64
	itob
	concat
	dup
	box_del
	pop
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:308
	// this.paymentBatchIdBox(paymentId).value = batchAsaId
	bytec 38 //  "pb"
	frame_dig 0 // paymentId: uint64
	itob
	concat
	frame_dig -2 // batchAsaId: uint64
	itob
	box_put

	// contracts/contractSupply/contract.algo.ts:309
	// this.paymentAmountBox(paymentId).value = amount
	bytec 39 //  "pa"
	frame_dig 0 // paymentId: uint64
	itob
	concat
	frame_dig -3 // amount: uint64
	itob
	box_put

	// contracts/contractSupply/contract.algo.ts:310
	// this.paymentCurrencyBox(paymentId).value = currency
	bytec 40 //  "pc"
	frame_dig 0 // paymentId: uint64
	itob
	concat
	dup
	box_del
	pop
	frame_dig -4 // currency: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:311
	// this.paymentTxBox(paymentId).value = txId
	bytec 41 //  "pt"
	frame_dig 0 // paymentId: uint64
	itob
	concat
	dup
	box_del
	pop
	frame_dig -5 // txId: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/contractSupply/contract.algo.ts:312
	// this.paymentTimestampBox(paymentId).value = timestamp
	bytec 36 //  "pts"
	frame_dig 0 // paymentId: uint64
	itob
	concat
	frame_dig -6 // timestamp: uint64
	itob
	box_put
	retsub

// getVerification(uint64)string
*abi_route_getVerification:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getVerification(uint64)string
	callsub getVerification
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getVerification(batchAsaId: BatchAsaId): string
getVerification:
	proto 1 1

	// contracts/contractSupply/contract.algo.ts:318
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:319
	// this.assertVerificationExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertVerificationExists

	// contracts/contractSupply/contract.algo.ts:320
	// return this.verificationResultBox(batchAsaId).value;
	bytec 9 //  "vrs"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.verificationResultBox(batchAsaId).value
	assert
	extract 2 0
	retsub

// getTotalVerifications()uint64
*abi_route_getTotalVerifications:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// execute getTotalVerifications()uint64
	callsub getTotalVerifications
	itob
	concat
	log
	intc 0 // 1
	return

// getTotalVerifications(): uint64
getTotalVerifications:
	proto 0 1

	// *if4_condition
	// contracts/contractSupply/contract.algo.ts:325
	// !this.totalVerifications.exists
	txna Applications 0
	bytec 6 //  "totalVerifications"
	app_global_get_ex
	swap
	pop
	!
	bz *if4_end

	// *if4_consequent
	// contracts/contractSupply/contract.algo.ts:325
	// return 0;
	intc 1 // 0
	retsub

*if4_end:
	// contracts/contractSupply/contract.algo.ts:326
	// return this.totalVerifications.value;
	bytec 6 //  "totalVerifications"
	app_global_get
	retsub

// getTotalBatches()uint64
*abi_route_getTotalBatches:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// execute getTotalBatches()uint64
	callsub getTotalBatches
	itob
	concat
	log
	intc 0 // 1
	return

// getTotalBatches(): uint64
getTotalBatches:
	proto 0 1

	// *if5_condition
	// contracts/contractSupply/contract.algo.ts:331
	// !this.totalBatches.exists
	txna Applications 0
	bytec 4 //  "totalBatches"
	app_global_get_ex
	swap
	pop
	!
	bz *if5_end

	// *if5_consequent
	// contracts/contractSupply/contract.algo.ts:331
	// return 0;
	intc 1 // 0
	retsub

*if5_end:
	// contracts/contractSupply/contract.algo.ts:332
	// return this.totalBatches.value;
	bytec 4 //  "totalBatches"
	app_global_get
	retsub

// getTotalPayments()uint64
*abi_route_getTotalPayments:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// execute getTotalPayments()uint64
	callsub getTotalPayments
	itob
	concat
	log
	intc 0 // 1
	return

// getTotalPayments(): uint64
getTotalPayments:
	proto 0 1

	// *if6_condition
	// contracts/contractSupply/contract.algo.ts:337
	// !this.totalPayments.exists
	txna Applications 0
	bytec 7 //  "totalPayments"
	app_global_get_ex
	swap
	pop
	!
	bz *if6_end

	// *if6_consequent
	// contracts/contractSupply/contract.algo.ts:337
	// return 0;
	intc 1 // 0
	retsub

*if6_end:
	// contracts/contractSupply/contract.algo.ts:338
	// return this.totalPayments.value;
	bytec 7 //  "totalPayments"
	app_global_get
	retsub

// getVerificationConfidence(uint64)uint64
*abi_route_getVerificationConfidence:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getVerificationConfidence(uint64)uint64
	callsub getVerificationConfidence
	itob
	concat
	log
	intc 0 // 1
	return

// getVerificationConfidence(batchAsaId: BatchAsaId): uint64
getVerificationConfidence:
	proto 1 1

	// contracts/contractSupply/contract.algo.ts:343
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:344
	// this.assertVerificationExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertVerificationExists

	// contracts/contractSupply/contract.algo.ts:345
	// return this.verificationConfidenceBox(batchAsaId).value;
	bytec 48 //  "vrc"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.verificationConfidenceBox(batchAsaId).value
	assert
	btoi
	retsub

// getVerificationReason(uint64)string
*abi_route_getVerificationReason:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getVerificationReason(uint64)string
	callsub getVerificationReason
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getVerificationReason(batchAsaId: BatchAsaId): string
getVerificationReason:
	proto 1 1

	// contracts/contractSupply/contract.algo.ts:350
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:351
	// this.assertVerificationExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertVerificationExists

	// contracts/contractSupply/contract.algo.ts:352
	// return this.verificationReasonBox(batchAsaId).value;
	bytec 49 //  "vrr"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.verificationReasonBox(batchAsaId).value
	assert
	extract 2 0
	retsub

// getVerificationVerifierAddr(uint64)string
*abi_route_getVerificationVerifierAddr:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getVerificationVerifierAddr(uint64)string
	callsub getVerificationVerifierAddr
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getVerificationVerifierAddr(batchAsaId: BatchAsaId): string
getVerificationVerifierAddr:
	proto 1 1

	// contracts/contractSupply/contract.algo.ts:357
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:358
	// this.assertVerificationExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertVerificationExists

	// contracts/contractSupply/contract.algo.ts:359
	// return this.verificationVerifierAddrBox(batchAsaId).value;
	bytec 50 //  "vrv"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.verificationVerifierAddrBox(batchAsaId).value
	assert
	extract 2 0
	retsub

// getVerificationTimestamp(uint64)uint64
*abi_route_getVerificationTimestamp:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getVerificationTimestamp(uint64)uint64
	callsub getVerificationTimestamp
	itob
	concat
	log
	intc 0 // 1
	return

// getVerificationTimestamp(batchAsaId: BatchAsaId): uint64
getVerificationTimestamp:
	proto 1 1

	// contracts/contractSupply/contract.algo.ts:364
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:365
	// this.assertVerificationExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertVerificationExists

	// contracts/contractSupply/contract.algo.ts:366
	// return this.verificationTimestampBox(batchAsaId).value;
	bytec 51 //  "vrt"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.verificationTimestampBox(batchAsaId).value
	assert
	btoi
	retsub

// getCarbonScore(uint64)uint64
*abi_route_getCarbonScore:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getCarbonScore(uint64)uint64
	callsub getCarbonScore
	itob
	concat
	log
	intc 0 // 1
	return

// getCarbonScore(batchAsaId: BatchAsaId): uint64
getCarbonScore:
	proto 1 1

	// *if7_condition
	// contracts/contractSupply/contract.algo.ts:371
	// !this.carbonScoreBox(batchAsaId).exists
	bytec 24 //  "ccs"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_len
	swap
	pop
	!
	bz *if7_end

	// *if7_consequent
	// contracts/contractSupply/contract.algo.ts:371
	// return 0;
	intc 1 // 0
	retsub

*if7_end:
	// contracts/contractSupply/contract.algo.ts:372
	// return this.carbonScoreBox(batchAsaId).value;
	bytec 24 //  "ccs"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.carbonScoreBox(batchAsaId).value
	assert
	btoi
	retsub

// getCarbonCredits(uint64)uint64
*abi_route_getCarbonCredits:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getCarbonCredits(uint64)uint64
	callsub getCarbonCredits
	itob
	concat
	log
	intc 0 // 1
	return

// getCarbonCredits(batchAsaId: BatchAsaId): uint64
getCarbonCredits:
	proto 1 1

	// *if8_condition
	// contracts/contractSupply/contract.algo.ts:377
	// !this.carbonCreditsBox(batchAsaId).exists
	bytec 25 //  "ccc"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_len
	swap
	pop
	!
	bz *if8_end

	// *if8_consequent
	// contracts/contractSupply/contract.algo.ts:377
	// return 0;
	intc 1 // 0
	retsub

*if8_end:
	// contracts/contractSupply/contract.algo.ts:378
	// return this.carbonCreditsBox(batchAsaId).value;
	bytec 25 //  "ccc"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.carbonCreditsBox(batchAsaId).value
	assert
	btoi
	retsub

// getCarbonDistance(uint64)uint64
*abi_route_getCarbonDistance:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getCarbonDistance(uint64)uint64
	callsub getCarbonDistance
	itob
	concat
	log
	intc 0 // 1
	return

// getCarbonDistance(batchAsaId: BatchAsaId): uint64
getCarbonDistance:
	proto 1 1

	// *if9_condition
	// contracts/contractSupply/contract.algo.ts:383
	// !this.carbonDistanceBox(batchAsaId).exists
	bytec 26 //  "ccd"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_len
	swap
	pop
	!
	bz *if9_end

	// *if9_consequent
	// contracts/contractSupply/contract.algo.ts:383
	// return 0;
	intc 1 // 0
	retsub

*if9_end:
	// contracts/contractSupply/contract.algo.ts:384
	// return this.carbonDistanceBox(batchAsaId).value;
	bytec 26 //  "ccd"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.carbonDistanceBox(batchAsaId).value
	assert
	btoi
	retsub

// getCarbonTransportMethod(uint64)string
*abi_route_getCarbonTransportMethod:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getCarbonTransportMethod(uint64)string
	callsub getCarbonTransportMethod
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getCarbonTransportMethod(batchAsaId: BatchAsaId): string
getCarbonTransportMethod:
	proto 1 1

	// *if10_condition
	// contracts/contractSupply/contract.algo.ts:389
	// !this.carbonTransportBox(batchAsaId).exists
	bytec 27 //  "cct"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_len
	swap
	pop
	!
	bz *if10_end

	// *if10_consequent
	// contracts/contractSupply/contract.algo.ts:389
	// return "";
	bytec 1 //  ""
	retsub

*if10_end:
	// contracts/contractSupply/contract.algo.ts:390
	// return this.carbonTransportBox(batchAsaId).value;
	bytec 27 //  "cct"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.carbonTransportBox(batchAsaId).value
	assert
	extract 2 0
	retsub

// getCarbonCalculatedAt(uint64)uint64
*abi_route_getCarbonCalculatedAt:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getCarbonCalculatedAt(uint64)uint64
	callsub getCarbonCalculatedAt
	itob
	concat
	log
	intc 0 // 1
	return

// getCarbonCalculatedAt(batchAsaId: BatchAsaId): uint64
getCarbonCalculatedAt:
	proto 1 1

	// *if11_condition
	// contracts/contractSupply/contract.algo.ts:395
	// !this.carbonCalculatedAtBox(batchAsaId).exists
	bytec 28 //  "cca"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_len
	swap
	pop
	!
	bz *if11_end

	// *if11_consequent
	// contracts/contractSupply/contract.algo.ts:395
	// return 0;
	intc 1 // 0
	retsub

*if11_end:
	// contracts/contractSupply/contract.algo.ts:396
	// return this.carbonCalculatedAtBox(batchAsaId).value;
	bytec 28 //  "cca"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.carbonCalculatedAtBox(batchAsaId).value
	assert
	btoi
	retsub

// getFarmerTotalBatches(string)uint64
*abi_route_getFarmerTotalBatches:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// farmerAddr: string
	txna ApplicationArgs 1
	extract 2 0

	// execute getFarmerTotalBatches(string)uint64
	callsub getFarmerTotalBatches
	itob
	concat
	log
	intc 0 // 1
	return

// getFarmerTotalBatches(farmerAddr: string): uint64
getFarmerTotalBatches:
	proto 1 1

	// *if12_condition
	// contracts/contractSupply/contract.algo.ts:401
	// !this.farmerTotalBatchesBox(farmerAddr).exists
	bytec 29 //  "frb"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_len
	swap
	pop
	!
	bz *if12_end

	// *if12_consequent
	// contracts/contractSupply/contract.algo.ts:401
	// return 0;
	intc 1 // 0
	retsub

*if12_end:
	// contracts/contractSupply/contract.algo.ts:402
	// return this.farmerTotalBatchesBox(farmerAddr).value;
	bytec 29 //  "frb"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get

	// box value does not exist: this.farmerTotalBatchesBox(farmerAddr).value
	assert
	btoi
	retsub

// getFarmerVerifiedCount(string)uint64
*abi_route_getFarmerVerifiedCount:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// farmerAddr: string
	txna ApplicationArgs 1
	extract 2 0

	// execute getFarmerVerifiedCount(string)uint64
	callsub getFarmerVerifiedCount
	itob
	concat
	log
	intc 0 // 1
	return

// getFarmerVerifiedCount(farmerAddr: string): uint64
getFarmerVerifiedCount:
	proto 1 1

	// *if13_condition
	// contracts/contractSupply/contract.algo.ts:407
	// !this.farmerVerifiedCountBox(farmerAddr).exists
	bytec 30 //  "frv"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_len
	swap
	pop
	!
	bz *if13_end

	// *if13_consequent
	// contracts/contractSupply/contract.algo.ts:407
	// return 0;
	intc 1 // 0
	retsub

*if13_end:
	// contracts/contractSupply/contract.algo.ts:408
	// return this.farmerVerifiedCountBox(farmerAddr).value;
	bytec 30 //  "frv"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get

	// box value does not exist: this.farmerVerifiedCountBox(farmerAddr).value
	assert
	btoi
	retsub

// getFarmerFlaggedCount(string)uint64
*abi_route_getFarmerFlaggedCount:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// farmerAddr: string
	txna ApplicationArgs 1
	extract 2 0

	// execute getFarmerFlaggedCount(string)uint64
	callsub getFarmerFlaggedCount
	itob
	concat
	log
	intc 0 // 1
	return

// getFarmerFlaggedCount(farmerAddr: string): uint64
getFarmerFlaggedCount:
	proto 1 1

	// *if14_condition
	// contracts/contractSupply/contract.algo.ts:413
	// !this.farmerFlaggedCountBox(farmerAddr).exists
	bytec 31 //  "frf"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_len
	swap
	pop
	!
	bz *if14_end

	// *if14_consequent
	// contracts/contractSupply/contract.algo.ts:413
	// return 0;
	intc 1 // 0
	retsub

*if14_end:
	// contracts/contractSupply/contract.algo.ts:414
	// return this.farmerFlaggedCountBox(farmerAddr).value;
	bytec 31 //  "frf"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get

	// box value does not exist: this.farmerFlaggedCountBox(farmerAddr).value
	assert
	btoi
	retsub

// getFarmerTier(string)string
*abi_route_getFarmerTier:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// farmerAddr: string
	txna ApplicationArgs 1
	extract 2 0

	// execute getFarmerTier(string)string
	callsub getFarmerTier
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getFarmerTier(farmerAddr: string): string
getFarmerTier:
	proto 1 1

	// *if15_condition
	// contracts/contractSupply/contract.algo.ts:419
	// !this.farmerTierBox(farmerAddr).exists
	bytec 32 //  "frt"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_len
	swap
	pop
	!
	bz *if15_end

	// *if15_consequent
	// contracts/contractSupply/contract.algo.ts:419
	// return "";
	bytec 1 //  ""
	retsub

*if15_end:
	// contracts/contractSupply/contract.algo.ts:420
	// return this.farmerTierBox(farmerAddr).value;
	bytec 32 //  "frt"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get

	// box value does not exist: this.farmerTierBox(farmerAddr).value
	assert
	extract 2 0
	retsub

// getFarmerCarbonCreditsTotal(string)uint64
*abi_route_getFarmerCarbonCreditsTotal:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// farmerAddr: string
	txna ApplicationArgs 1
	extract 2 0

	// execute getFarmerCarbonCreditsTotal(string)uint64
	callsub getFarmerCarbonCreditsTotal
	itob
	concat
	log
	intc 0 // 1
	return

// getFarmerCarbonCreditsTotal(farmerAddr: string): uint64
getFarmerCarbonCreditsTotal:
	proto 1 1

	// *if16_condition
	// contracts/contractSupply/contract.algo.ts:425
	// !this.farmerCarbonCreditsBox(farmerAddr).exists
	bytec 33 //  "frc"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_len
	swap
	pop
	!
	bz *if16_end

	// *if16_consequent
	// contracts/contractSupply/contract.algo.ts:425
	// return 0;
	intc 1 // 0
	retsub

*if16_end:
	// contracts/contractSupply/contract.algo.ts:426
	// return this.farmerCarbonCreditsBox(farmerAddr).value;
	bytec 33 //  "frc"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get

	// box value does not exist: this.farmerCarbonCreditsBox(farmerAddr).value
	assert
	btoi
	retsub

// getFarmerPaymentsTotal(string)uint64
*abi_route_getFarmerPaymentsTotal:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// farmerAddr: string
	txna ApplicationArgs 1
	extract 2 0

	// execute getFarmerPaymentsTotal(string)uint64
	callsub getFarmerPaymentsTotal
	itob
	concat
	log
	intc 0 // 1
	return

// getFarmerPaymentsTotal(farmerAddr: string): uint64
getFarmerPaymentsTotal:
	proto 1 1

	// *if17_condition
	// contracts/contractSupply/contract.algo.ts:431
	// !this.farmerPaymentsTotalBox(farmerAddr).exists
	bytec 34 //  "frp"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_len
	swap
	pop
	!
	bz *if17_end

	// *if17_consequent
	// contracts/contractSupply/contract.algo.ts:431
	// return 0;
	intc 1 // 0
	retsub

*if17_end:
	// contracts/contractSupply/contract.algo.ts:432
	// return this.farmerPaymentsTotalBox(farmerAddr).value;
	bytec 34 //  "frp"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get

	// box value does not exist: this.farmerPaymentsTotalBox(farmerAddr).value
	assert
	btoi
	retsub

// getFarmerLastUpdated(string)uint64
*abi_route_getFarmerLastUpdated:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// farmerAddr: string
	txna ApplicationArgs 1
	extract 2 0

	// execute getFarmerLastUpdated(string)uint64
	callsub getFarmerLastUpdated
	itob
	concat
	log
	intc 0 // 1
	return

// getFarmerLastUpdated(farmerAddr: string): uint64
getFarmerLastUpdated:
	proto 1 1

	// *if18_condition
	// contracts/contractSupply/contract.algo.ts:437
	// !this.farmerLastUpdatedBox(farmerAddr).exists
	bytec 35 //  "fru"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_len
	swap
	pop
	!
	bz *if18_end

	// *if18_consequent
	// contracts/contractSupply/contract.algo.ts:437
	// return 0;
	intc 1 // 0
	retsub

*if18_end:
	// contracts/contractSupply/contract.algo.ts:438
	// return this.farmerLastUpdatedBox(farmerAddr).value;
	bytec 35 //  "fru"
	frame_dig -1 // farmerAddr: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	box_get

	// box value does not exist: this.farmerLastUpdatedBox(farmerAddr).value
	assert
	btoi
	retsub

// getPaymentFarmerAddr(uint64)string
*abi_route_getPaymentFarmerAddr:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// paymentId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getPaymentFarmerAddr(uint64)string
	callsub getPaymentFarmerAddr
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getPaymentFarmerAddr(paymentId: uint64): string
getPaymentFarmerAddr:
	proto 1 1

	// *if19_condition
	// contracts/contractSupply/contract.algo.ts:443
	// !this.paymentFarmerAddrBox(paymentId).exists
	bytec 37 //  "pf"
	frame_dig -1 // paymentId: uint64
	itob
	concat
	box_len
	swap
	pop
	!
	bz *if19_end

	// *if19_consequent
	// contracts/contractSupply/contract.algo.ts:443
	// return "";
	bytec 1 //  ""
	retsub

*if19_end:
	// contracts/contractSupply/contract.algo.ts:444
	// return this.paymentFarmerAddrBox(paymentId).value;
	bytec 37 //  "pf"
	frame_dig -1 // paymentId: uint64
	itob
	concat
	box_get

	// box value does not exist: this.paymentFarmerAddrBox(paymentId).value
	assert
	extract 2 0
	retsub

// getPaymentBatchId(uint64)uint64
*abi_route_getPaymentBatchId:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// paymentId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getPaymentBatchId(uint64)uint64
	callsub getPaymentBatchId
	itob
	concat
	log
	intc 0 // 1
	return

// getPaymentBatchId(paymentId: uint64): uint64
getPaymentBatchId:
	proto 1 1

	// *if20_condition
	// contracts/contractSupply/contract.algo.ts:449
	// !this.paymentBatchIdBox(paymentId).exists
	bytec 38 //  "pb"
	frame_dig -1 // paymentId: uint64
	itob
	concat
	box_len
	swap
	pop
	!
	bz *if20_end

	// *if20_consequent
	// contracts/contractSupply/contract.algo.ts:449
	// return 0;
	intc 1 // 0
	retsub

*if20_end:
	// contracts/contractSupply/contract.algo.ts:450
	// return this.paymentBatchIdBox(paymentId).value;
	bytec 38 //  "pb"
	frame_dig -1 // paymentId: uint64
	itob
	concat
	box_get

	// box value does not exist: this.paymentBatchIdBox(paymentId).value
	assert
	btoi
	retsub

// getPaymentAmount(uint64)uint64
*abi_route_getPaymentAmount:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// paymentId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getPaymentAmount(uint64)uint64
	callsub getPaymentAmount
	itob
	concat
	log
	intc 0 // 1
	return

// getPaymentAmount(paymentId: uint64): uint64
getPaymentAmount:
	proto 1 1

	// *if21_condition
	// contracts/contractSupply/contract.algo.ts:455
	// !this.paymentAmountBox(paymentId).exists
	bytec 39 //  "pa"
	frame_dig -1 // paymentId: uint64
	itob
	concat
	box_len
	swap
	pop
	!
	bz *if21_end

	// *if21_consequent
	// contracts/contractSupply/contract.algo.ts:455
	// return 0;
	intc 1 // 0
	retsub

*if21_end:
	// contracts/contractSupply/contract.algo.ts:456
	// return this.paymentAmountBox(paymentId).value;
	bytec 39 //  "pa"
	frame_dig -1 // paymentId: uint64
	itob
	concat
	box_get

	// box value does not exist: this.paymentAmountBox(paymentId).value
	assert
	btoi
	retsub

// getPaymentCurrency(uint64)string
*abi_route_getPaymentCurrency:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// paymentId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getPaymentCurrency(uint64)string
	callsub getPaymentCurrency
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getPaymentCurrency(paymentId: uint64): string
getPaymentCurrency:
	proto 1 1

	// *if22_condition
	// contracts/contractSupply/contract.algo.ts:461
	// !this.paymentCurrencyBox(paymentId).exists
	bytec 40 //  "pc"
	frame_dig -1 // paymentId: uint64
	itob
	concat
	box_len
	swap
	pop
	!
	bz *if22_end

	// *if22_consequent
	// contracts/contractSupply/contract.algo.ts:461
	// return "";
	bytec 1 //  ""
	retsub

*if22_end:
	// contracts/contractSupply/contract.algo.ts:462
	// return this.paymentCurrencyBox(paymentId).value;
	bytec 40 //  "pc"
	frame_dig -1 // paymentId: uint64
	itob
	concat
	box_get

	// box value does not exist: this.paymentCurrencyBox(paymentId).value
	assert
	extract 2 0
	retsub

// getPaymentTxId(uint64)string
*abi_route_getPaymentTxId:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// paymentId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getPaymentTxId(uint64)string
	callsub getPaymentTxId
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getPaymentTxId(paymentId: uint64): string
getPaymentTxId:
	proto 1 1

	// *if23_condition
	// contracts/contractSupply/contract.algo.ts:467
	// !this.paymentTxBox(paymentId).exists
	bytec 41 //  "pt"
	frame_dig -1 // paymentId: uint64
	itob
	concat
	box_len
	swap
	pop
	!
	bz *if23_end

	// *if23_consequent
	// contracts/contractSupply/contract.algo.ts:467
	// return "";
	bytec 1 //  ""
	retsub

*if23_end:
	// contracts/contractSupply/contract.algo.ts:468
	// return this.paymentTxBox(paymentId).value;
	bytec 41 //  "pt"
	frame_dig -1 // paymentId: uint64
	itob
	concat
	box_get

	// box value does not exist: this.paymentTxBox(paymentId).value
	assert
	extract 2 0
	retsub

// getPaymentTimestamp(uint64)uint64
*abi_route_getPaymentTimestamp:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// paymentId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getPaymentTimestamp(uint64)uint64
	callsub getPaymentTimestamp
	itob
	concat
	log
	intc 0 // 1
	return

// getPaymentTimestamp(paymentId: uint64): uint64
getPaymentTimestamp:
	proto 1 1

	// *if24_condition
	// contracts/contractSupply/contract.algo.ts:473
	// !this.paymentTimestampBox(paymentId).exists
	bytec 36 //  "pts"
	frame_dig -1 // paymentId: uint64
	itob
	concat
	box_len
	swap
	pop
	!
	bz *if24_end

	// *if24_consequent
	// contracts/contractSupply/contract.algo.ts:473
	// return 0;
	intc 1 // 0
	retsub

*if24_end:
	// contracts/contractSupply/contract.algo.ts:474
	// return this.paymentTimestampBox(paymentId).value;
	bytec 36 //  "pts"
	frame_dig -1 // paymentId: uint64
	itob
	concat
	box_get

	// box value does not exist: this.paymentTimestampBox(paymentId).value
	assert
	btoi
	retsub

// getBatch(uint64)string
*abi_route_getBatch:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getBatch(uint64)string
	callsub getBatch
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getBatch(batchAsaId: BatchAsaId): string
getBatch:
	proto 1 1

	// contracts/contractSupply/contract.algo.ts:479
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:480
	// return this.batchCropTypeBox(batchAsaId).value
	//             + "|" + this.batchFarmGpsBox(batchAsaId).value
	//             + "|" + this.batchOrganicCertIdBox(batchAsaId).value
	//             + "|" + this.batchFarmerAddrBox(batchAsaId).value;
	bytec 10 //  "bct"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.batchCropTypeBox(batchAsaId).value
	assert
	extract 2 0
	bytec 2 //  "|"
	concat
	bytec 15 //  "bfg"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.batchFarmGpsBox(batchAsaId).value
	assert
	extract 2 0
	concat
	bytec 2 //  "|"
	concat
	bytec 16 //  "boc"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.batchOrganicCertIdBox(batchAsaId).value
	assert
	extract 2 0
	concat
	bytec 2 //  "|"
	concat
	bytec 17 //  "bfa"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.batchFarmerAddrBox(batchAsaId).value
	assert
	extract 2 0
	concat
	retsub

// hasBatch(uint64)bool
*abi_route_hasBatch:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute hasBatch(uint64)bool
	callsub hasBatch
	bytec 53 // 0x00
	intc 1 // 0
	uncover 2
	setbit
	concat
	log
	intc 0 // 1
	return

// hasBatch(batchAsaId: BatchAsaId): boolean
hasBatch:
	proto 1 1

	// contracts/contractSupply/contract.algo.ts:488
	// return this.batchCropTypeBox(batchAsaId).exists;
	bytec 10 //  "bct"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_len
	swap
	pop
	retsub

// getCheckpoint(uint64,uint64)string
*abi_route_getCheckpoint:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// index: uint64
	txna ApplicationArgs 2
	btoi

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getCheckpoint(uint64,uint64)string
	callsub getCheckpoint
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getCheckpoint(batchAsaId: BatchAsaId, index: uint64): string
getCheckpoint:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:493
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:494
	// this.assertCheckpointIndex(batchAsaId, index)
	frame_dig -2 // index: uint64
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertCheckpointIndex

	// contracts/contractSupply/contract.algo.ts:495
	// pk = batchAsaId * 10000 + index
	frame_dig -1 // batchAsaId: BatchAsaId
	intc 2 // 10000
	*
	frame_dig -2 // index: uint64
	+
	frame_bury 0 // pk: uint64

	// contracts/contractSupply/contract.algo.ts:496
	// return this.checkpointGpsBox(pk).value
	//             + "|" + this.checkpointHandlerTypeBox(pk).value
	//             + "|" + this.checkpointNotesBox(pk).value
	//             + "|" + this.checkpointPhotoHashBox(pk).value;
	bytec 18 //  "cpg"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.checkpointGpsBox(pk).value
	assert
	extract 2 0
	bytec 2 //  "|"
	concat
	bytec 13 //  "cphn"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.checkpointHandlerTypeBox(pk).value
	assert
	extract 2 0
	concat
	bytec 2 //  "|"
	concat
	bytec 14 //  "cpno"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.checkpointNotesBox(pk).value
	assert
	extract 2 0
	concat
	bytec 2 //  "|"
	concat
	bytec 19 //  "cpp"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.checkpointPhotoHashBox(pk).value
	assert
	extract 2 0
	concat

	// set the subroutine return value
	frame_bury 0
	retsub

// getCheckpointCount(uint64)uint64
*abi_route_getCheckpointCount:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getCheckpointCount(uint64)uint64
	callsub getCheckpointCount
	itob
	concat
	log
	intc 0 // 1
	return

// getCheckpointCount(batchAsaId: BatchAsaId): uint64
getCheckpointCount:
	proto 1 1

	// *if25_condition
	// contracts/contractSupply/contract.algo.ts:504
	// !this.checkpointCountBox(batchAsaId).exists
	bytec 5 //  "cpn"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_len
	swap
	pop
	!
	bz *if25_end

	// *if25_consequent
	// contracts/contractSupply/contract.algo.ts:504
	// return 0;
	intc 1 // 0
	retsub

*if25_end:
	// contracts/contractSupply/contract.algo.ts:505
	// return this.checkpointCountBox(batchAsaId).value;
	bytec 5 //  "cpn"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.checkpointCountBox(batchAsaId).value
	assert
	btoi
	retsub

// getHandoff(uint64,uint64)string
*abi_route_getHandoff:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// handoffIndex: uint64
	txna ApplicationArgs 2
	btoi

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getHandoff(uint64,uint64)string
	callsub getHandoff
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getHandoff(batchAsaId: BatchAsaId, handoffIndex: uint64): string
getHandoff:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:510
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:511
	// this.assertHandoffIndex(batchAsaId, handoffIndex)
	frame_dig -2 // handoffIndex: uint64
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertHandoffIndex

	// contracts/contractSupply/contract.algo.ts:512
	// pk = batchAsaId * 10000 + handoffIndex
	frame_dig -1 // batchAsaId: BatchAsaId
	intc 2 // 10000
	*
	frame_dig -2 // handoffIndex: uint64
	+
	frame_bury 0 // pk: uint64

	// contracts/contractSupply/contract.algo.ts:513
	// return this.handoffFromAddrBox(pk).value
	//             + "|" + this.handoffToAddrBox(pk).value
	//             + "|" + this.handoffTypeBox(pk).value
	//             + "|" + this.handoffStatusBox(pk).value;
	bytec 20 //  "hof"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.handoffFromAddrBox(pk).value
	assert
	extract 2 0
	bytec 2 //  "|"
	concat
	bytec 21 //  "hot"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.handoffToAddrBox(pk).value
	assert
	extract 2 0
	concat
	bytec 2 //  "|"
	concat
	bytec 22 //  "hoy"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.handoffTypeBox(pk).value
	assert
	extract 2 0
	concat
	bytec 2 //  "|"
	concat
	bytec 11 //  "hos"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.handoffStatusBox(pk).value
	assert
	extract 2 0
	concat

	// set the subroutine return value
	frame_bury 0
	retsub

// hasHandoff(uint64,uint64)bool
*abi_route_hasHandoff:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// handoffIndex: uint64
	txna ApplicationArgs 2
	btoi

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute hasHandoff(uint64,uint64)bool
	callsub hasHandoff
	bytec 53 // 0x00
	intc 1 // 0
	uncover 2
	setbit
	concat
	log
	intc 0 // 1
	return

// hasHandoff(batchAsaId: BatchAsaId, handoffIndex: uint64): boolean
hasHandoff:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// *if26_condition
	// contracts/contractSupply/contract.algo.ts:521
	// !this.handoffCountBox(batchAsaId).exists
	bytec 3 //  "hon"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_len
	swap
	pop
	!
	bz *if26_end

	// *if26_consequent
	// contracts/contractSupply/contract.algo.ts:521
	// return false;
	intc 1 // 0
	b *hasHandoff*return

*if26_end:
	// contracts/contractSupply/contract.algo.ts:522
	// count = this.handoffCountBox(batchAsaId).value
	bytec 3 //  "hon"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.handoffCountBox(batchAsaId).value
	assert
	btoi
	frame_bury 0 // count: uint64

	// *if27_condition
	// contracts/contractSupply/contract.algo.ts:523
	// handoffIndex > count
	frame_dig -2 // handoffIndex: uint64
	frame_dig 0 // count: uint64
	>
	bz *if27_end

	// *if27_consequent
	// contracts/contractSupply/contract.algo.ts:523
	// return false;
	intc 1 // 0
	b *hasHandoff*return

*if27_end:
	// *if28_condition
	// contracts/contractSupply/contract.algo.ts:524
	// handoffIndex === 0
	frame_dig -2 // handoffIndex: uint64
	intc 1 // 0
	==
	bz *if28_end

	// *if28_consequent
	// contracts/contractSupply/contract.algo.ts:524
	// return false;
	intc 1 // 0
	b *hasHandoff*return

*if28_end:
	// contracts/contractSupply/contract.algo.ts:525
	// return true;
	intc 0 // 1

*hasHandoff*return:
	// set the subroutine return value
	frame_bury 0
	retsub

// getHandoffCount(uint64)uint64
*abi_route_getHandoffCount:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getHandoffCount(uint64)uint64
	callsub getHandoffCount
	itob
	concat
	log
	intc 0 // 1
	return

// getHandoffCount(batchAsaId: BatchAsaId): uint64
getHandoffCount:
	proto 1 1

	// *if29_condition
	// contracts/contractSupply/contract.algo.ts:530
	// !this.handoffCountBox(batchAsaId).exists
	bytec 3 //  "hon"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_len
	swap
	pop
	!
	bz *if29_end

	// *if29_consequent
	// contracts/contractSupply/contract.algo.ts:530
	// return 0;
	intc 1 // 0
	retsub

*if29_end:
	// contracts/contractSupply/contract.algo.ts:531
	// return this.handoffCountBox(batchAsaId).value;
	bytec 3 //  "hon"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.handoffCountBox(batchAsaId).value
	assert
	btoi
	retsub

// getBatchWeight(uint64)uint64
*abi_route_getBatchWeight:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getBatchWeight(uint64)uint64
	callsub getBatchWeight
	itob
	concat
	log
	intc 0 // 1
	return

// getBatchWeight(batchAsaId: BatchAsaId): uint64
getBatchWeight:
	proto 1 1

	// contracts/contractSupply/contract.algo.ts:536
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:537
	// return this.batchWeightBox(batchAsaId).value;
	bytec 52 //  "bw"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.batchWeightBox(batchAsaId).value
	assert
	btoi
	retsub

// getBatchCropType(uint64)string
*abi_route_getBatchCropType:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getBatchCropType(uint64)string
	callsub getBatchCropType
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getBatchCropType(batchAsaId: BatchAsaId): string
getBatchCropType:
	proto 1 1

	// contracts/contractSupply/contract.algo.ts:542
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:543
	// return this.batchCropTypeBox(batchAsaId).value;
	bytec 10 //  "bct"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.batchCropTypeBox(batchAsaId).value
	assert
	extract 2 0
	retsub

// getBatchFarmGps(uint64)string
*abi_route_getBatchFarmGps:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getBatchFarmGps(uint64)string
	callsub getBatchFarmGps
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getBatchFarmGps(batchAsaId: BatchAsaId): string
getBatchFarmGps:
	proto 1 1

	// contracts/contractSupply/contract.algo.ts:548
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:549
	// return this.batchFarmGpsBox(batchAsaId).value;
	bytec 15 //  "bfg"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.batchFarmGpsBox(batchAsaId).value
	assert
	extract 2 0
	retsub

// getBatchFarmingPractices(uint64)string
*abi_route_getBatchFarmingPractices:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getBatchFarmingPractices(uint64)string
	callsub getBatchFarmingPractices
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getBatchFarmingPractices(batchAsaId: BatchAsaId): string
getBatchFarmingPractices:
	proto 1 1

	// contracts/contractSupply/contract.algo.ts:554
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:555
	// return this.batchFarmingPracticesBox(batchAsaId).value;
	bytec 43 //  "bfp"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.batchFarmingPracticesBox(batchAsaId).value
	assert
	extract 2 0
	retsub

// getBatchOrganicCertId(uint64)string
*abi_route_getBatchOrganicCertId:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getBatchOrganicCertId(uint64)string
	callsub getBatchOrganicCertId
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getBatchOrganicCertId(batchAsaId: BatchAsaId): string
getBatchOrganicCertId:
	proto 1 1

	// contracts/contractSupply/contract.algo.ts:560
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:561
	// return this.batchOrganicCertIdBox(batchAsaId).value;
	bytec 16 //  "boc"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.batchOrganicCertIdBox(batchAsaId).value
	assert
	extract 2 0
	retsub

// getBatchFarmerAddr(uint64)string
*abi_route_getBatchFarmerAddr:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getBatchFarmerAddr(uint64)string
	callsub getBatchFarmerAddr
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getBatchFarmerAddr(batchAsaId: BatchAsaId): string
getBatchFarmerAddr:
	proto 1 1

	// contracts/contractSupply/contract.algo.ts:566
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:567
	// return this.batchFarmerAddrBox(batchAsaId).value;
	bytec 17 //  "bfa"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.batchFarmerAddrBox(batchAsaId).value
	assert
	extract 2 0
	retsub

// getBatchCreatedAt(uint64)uint64
*abi_route_getBatchCreatedAt:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getBatchCreatedAt(uint64)uint64
	callsub getBatchCreatedAt
	itob
	concat
	log
	intc 0 // 1
	return

// getBatchCreatedAt(batchAsaId: BatchAsaId): uint64
getBatchCreatedAt:
	proto 1 1

	// contracts/contractSupply/contract.algo.ts:572
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:573
	// return this.batchCreatedAtBox(batchAsaId).value;
	bytec 44 //  "bca"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.batchCreatedAtBox(batchAsaId).value
	assert
	btoi
	retsub

// getBatchAsaId(uint64)uint64
*abi_route_getBatchAsaId:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getBatchAsaId(uint64)uint64
	callsub getBatchAsaId
	itob
	concat
	log
	intc 0 // 1
	return

// getBatchAsaId(batchAsaId: BatchAsaId): uint64
getBatchAsaId:
	proto 1 1

	// contracts/contractSupply/contract.algo.ts:578
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// *if30_condition
	// contracts/contractSupply/contract.algo.ts:579
	// !this.batchAsaIdBox(batchAsaId).exists
	bytec 12 //  "bas"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_len
	swap
	pop
	!
	bz *if30_end

	// *if30_consequent
	// contracts/contractSupply/contract.algo.ts:579
	// return 0;
	intc 1 // 0
	retsub

*if30_end:
	// contracts/contractSupply/contract.algo.ts:580
	// return this.batchAsaIdBox(batchAsaId).value;
	bytec 12 //  "bas"
	frame_dig -1 // batchAsaId: BatchAsaId
	itob
	concat
	box_get

	// box value does not exist: this.batchAsaIdBox(batchAsaId).value
	assert
	btoi
	retsub

// getCheckpointTemperature(uint64,uint64)uint64
*abi_route_getCheckpointTemperature:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// index: uint64
	txna ApplicationArgs 2
	btoi

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getCheckpointTemperature(uint64,uint64)uint64
	callsub getCheckpointTemperature
	itob
	concat
	log
	intc 0 // 1
	return

// getCheckpointTemperature(batchAsaId: BatchAsaId, index: uint64): uint64
getCheckpointTemperature:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:585
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:586
	// this.assertCheckpointIndex(batchAsaId, index)
	frame_dig -2 // index: uint64
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertCheckpointIndex

	// contracts/contractSupply/contract.algo.ts:587
	// pk = batchAsaId * 10000 + index
	frame_dig -1 // batchAsaId: BatchAsaId
	intc 2 // 10000
	*
	frame_dig -2 // index: uint64
	+
	frame_bury 0 // pk: uint64

	// contracts/contractSupply/contract.algo.ts:588
	// return this.checkpointTemperatureBox(pk).value;
	bytec 45 //  "cpt"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.checkpointTemperatureBox(pk).value
	assert
	btoi

	// set the subroutine return value
	frame_bury 0
	retsub

// getCheckpointHumidity(uint64,uint64)uint64
*abi_route_getCheckpointHumidity:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// index: uint64
	txna ApplicationArgs 2
	btoi

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getCheckpointHumidity(uint64,uint64)uint64
	callsub getCheckpointHumidity
	itob
	concat
	log
	intc 0 // 1
	return

// getCheckpointHumidity(batchAsaId: BatchAsaId, index: uint64): uint64
getCheckpointHumidity:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:593
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:594
	// this.assertCheckpointIndex(batchAsaId, index)
	frame_dig -2 // index: uint64
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertCheckpointIndex

	// contracts/contractSupply/contract.algo.ts:595
	// pk = batchAsaId * 10000 + index
	frame_dig -1 // batchAsaId: BatchAsaId
	intc 2 // 10000
	*
	frame_dig -2 // index: uint64
	+
	frame_bury 0 // pk: uint64

	// contracts/contractSupply/contract.algo.ts:596
	// return this.checkpointHumidityBox(pk).value;
	bytec 46 //  "cph"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.checkpointHumidityBox(pk).value
	assert
	btoi

	// set the subroutine return value
	frame_bury 0
	retsub

// getCheckpointGps(uint64,uint64)string
*abi_route_getCheckpointGps:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// index: uint64
	txna ApplicationArgs 2
	btoi

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getCheckpointGps(uint64,uint64)string
	callsub getCheckpointGps
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getCheckpointGps(batchAsaId: BatchAsaId, index: uint64): string
getCheckpointGps:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:601
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:602
	// this.assertCheckpointIndex(batchAsaId, index)
	frame_dig -2 // index: uint64
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertCheckpointIndex

	// contracts/contractSupply/contract.algo.ts:603
	// pk = batchAsaId * 10000 + index
	frame_dig -1 // batchAsaId: BatchAsaId
	intc 2 // 10000
	*
	frame_dig -2 // index: uint64
	+
	frame_bury 0 // pk: uint64

	// contracts/contractSupply/contract.algo.ts:604
	// return this.checkpointGpsBox(pk).value;
	bytec 18 //  "cpg"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.checkpointGpsBox(pk).value
	assert
	extract 2 0

	// set the subroutine return value
	frame_bury 0
	retsub

// getCheckpointHandlerType(uint64,uint64)string
*abi_route_getCheckpointHandlerType:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// index: uint64
	txna ApplicationArgs 2
	btoi

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getCheckpointHandlerType(uint64,uint64)string
	callsub getCheckpointHandlerType
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getCheckpointHandlerType(batchAsaId: BatchAsaId, index: uint64): string
getCheckpointHandlerType:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:609
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:610
	// this.assertCheckpointIndex(batchAsaId, index)
	frame_dig -2 // index: uint64
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertCheckpointIndex

	// contracts/contractSupply/contract.algo.ts:611
	// pk = batchAsaId * 10000 + index
	frame_dig -1 // batchAsaId: BatchAsaId
	intc 2 // 10000
	*
	frame_dig -2 // index: uint64
	+
	frame_bury 0 // pk: uint64

	// contracts/contractSupply/contract.algo.ts:612
	// return this.checkpointHandlerTypeBox(pk).value;
	bytec 13 //  "cphn"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.checkpointHandlerTypeBox(pk).value
	assert
	extract 2 0

	// set the subroutine return value
	frame_bury 0
	retsub

// getCheckpointNotes(uint64,uint64)string
*abi_route_getCheckpointNotes:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// index: uint64
	txna ApplicationArgs 2
	btoi

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getCheckpointNotes(uint64,uint64)string
	callsub getCheckpointNotes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getCheckpointNotes(batchAsaId: BatchAsaId, index: uint64): string
getCheckpointNotes:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:617
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:618
	// this.assertCheckpointIndex(batchAsaId, index)
	frame_dig -2 // index: uint64
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertCheckpointIndex

	// contracts/contractSupply/contract.algo.ts:619
	// pk = batchAsaId * 10000 + index
	frame_dig -1 // batchAsaId: BatchAsaId
	intc 2 // 10000
	*
	frame_dig -2 // index: uint64
	+
	frame_bury 0 // pk: uint64

	// contracts/contractSupply/contract.algo.ts:620
	// return this.checkpointNotesBox(pk).value;
	bytec 14 //  "cpno"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.checkpointNotesBox(pk).value
	assert
	extract 2 0

	// set the subroutine return value
	frame_bury 0
	retsub

// getCheckpointPhotoHash(uint64,uint64)string
*abi_route_getCheckpointPhotoHash:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// index: uint64
	txna ApplicationArgs 2
	btoi

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getCheckpointPhotoHash(uint64,uint64)string
	callsub getCheckpointPhotoHash
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getCheckpointPhotoHash(batchAsaId: BatchAsaId, index: uint64): string
getCheckpointPhotoHash:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:625
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:626
	// this.assertCheckpointIndex(batchAsaId, index)
	frame_dig -2 // index: uint64
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertCheckpointIndex

	// contracts/contractSupply/contract.algo.ts:627
	// pk = batchAsaId * 10000 + index
	frame_dig -1 // batchAsaId: BatchAsaId
	intc 2 // 10000
	*
	frame_dig -2 // index: uint64
	+
	frame_bury 0 // pk: uint64

	// contracts/contractSupply/contract.algo.ts:628
	// return this.checkpointPhotoHashBox(pk).value;
	bytec 19 //  "cpp"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.checkpointPhotoHashBox(pk).value
	assert
	extract 2 0

	// set the subroutine return value
	frame_bury 0
	retsub

// getCheckpointTimestamp(uint64,uint64)uint64
*abi_route_getCheckpointTimestamp:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// index: uint64
	txna ApplicationArgs 2
	btoi

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getCheckpointTimestamp(uint64,uint64)uint64
	callsub getCheckpointTimestamp
	itob
	concat
	log
	intc 0 // 1
	return

// getCheckpointTimestamp(batchAsaId: BatchAsaId, index: uint64): uint64
getCheckpointTimestamp:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:633
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:634
	// this.assertCheckpointIndex(batchAsaId, index)
	frame_dig -2 // index: uint64
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertCheckpointIndex

	// contracts/contractSupply/contract.algo.ts:635
	// pk = batchAsaId * 10000 + index
	frame_dig -1 // batchAsaId: BatchAsaId
	intc 2 // 10000
	*
	frame_dig -2 // index: uint64
	+
	frame_bury 0 // pk: uint64

	// contracts/contractSupply/contract.algo.ts:636
	// return this.checkpointTimestampBox(pk).value;
	bytec 42 //  "cpts"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.checkpointTimestampBox(pk).value
	assert
	btoi

	// set the subroutine return value
	frame_bury 0
	retsub

// getHandoffFromAddr(uint64,uint64)string
*abi_route_getHandoffFromAddr:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// handoffIndex: uint64
	txna ApplicationArgs 2
	btoi

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getHandoffFromAddr(uint64,uint64)string
	callsub getHandoffFromAddr
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getHandoffFromAddr(batchAsaId: BatchAsaId, handoffIndex: uint64): string
getHandoffFromAddr:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:641
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:642
	// this.assertHandoffIndex(batchAsaId, handoffIndex)
	frame_dig -2 // handoffIndex: uint64
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertHandoffIndex

	// contracts/contractSupply/contract.algo.ts:643
	// pk = batchAsaId * 10000 + handoffIndex
	frame_dig -1 // batchAsaId: BatchAsaId
	intc 2 // 10000
	*
	frame_dig -2 // handoffIndex: uint64
	+
	frame_bury 0 // pk: uint64

	// contracts/contractSupply/contract.algo.ts:644
	// return this.handoffFromAddrBox(pk).value;
	bytec 20 //  "hof"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.handoffFromAddrBox(pk).value
	assert
	extract 2 0

	// set the subroutine return value
	frame_bury 0
	retsub

// getHandoffToAddr(uint64,uint64)string
*abi_route_getHandoffToAddr:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// handoffIndex: uint64
	txna ApplicationArgs 2
	btoi

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getHandoffToAddr(uint64,uint64)string
	callsub getHandoffToAddr
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getHandoffToAddr(batchAsaId: BatchAsaId, handoffIndex: uint64): string
getHandoffToAddr:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:649
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:650
	// this.assertHandoffIndex(batchAsaId, handoffIndex)
	frame_dig -2 // handoffIndex: uint64
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertHandoffIndex

	// contracts/contractSupply/contract.algo.ts:651
	// pk = batchAsaId * 10000 + handoffIndex
	frame_dig -1 // batchAsaId: BatchAsaId
	intc 2 // 10000
	*
	frame_dig -2 // handoffIndex: uint64
	+
	frame_bury 0 // pk: uint64

	// contracts/contractSupply/contract.algo.ts:652
	// return this.handoffToAddrBox(pk).value;
	bytec 21 //  "hot"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.handoffToAddrBox(pk).value
	assert
	extract 2 0

	// set the subroutine return value
	frame_bury 0
	retsub

// getHandoffType(uint64,uint64)string
*abi_route_getHandoffType:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// handoffIndex: uint64
	txna ApplicationArgs 2
	btoi

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getHandoffType(uint64,uint64)string
	callsub getHandoffType
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getHandoffType(batchAsaId: BatchAsaId, handoffIndex: uint64): string
getHandoffType:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:657
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:658
	// this.assertHandoffIndex(batchAsaId, handoffIndex)
	frame_dig -2 // handoffIndex: uint64
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertHandoffIndex

	// contracts/contractSupply/contract.algo.ts:659
	// pk = batchAsaId * 10000 + handoffIndex
	frame_dig -1 // batchAsaId: BatchAsaId
	intc 2 // 10000
	*
	frame_dig -2 // handoffIndex: uint64
	+
	frame_bury 0 // pk: uint64

	// contracts/contractSupply/contract.algo.ts:660
	// return this.handoffTypeBox(pk).value;
	bytec 22 //  "hoy"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.handoffTypeBox(pk).value
	assert
	extract 2 0

	// set the subroutine return value
	frame_bury 0
	retsub

// getHandoffStatus(uint64,uint64)string
*abi_route_getHandoffStatus:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// handoffIndex: uint64
	txna ApplicationArgs 2
	btoi

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getHandoffStatus(uint64,uint64)string
	callsub getHandoffStatus
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getHandoffStatus(batchAsaId: BatchAsaId, handoffIndex: uint64): string
getHandoffStatus:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:665
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:666
	// this.assertHandoffIndex(batchAsaId, handoffIndex)
	frame_dig -2 // handoffIndex: uint64
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertHandoffIndex

	// contracts/contractSupply/contract.algo.ts:667
	// pk = batchAsaId * 10000 + handoffIndex
	frame_dig -1 // batchAsaId: BatchAsaId
	intc 2 // 10000
	*
	frame_dig -2 // handoffIndex: uint64
	+
	frame_bury 0 // pk: uint64

	// contracts/contractSupply/contract.algo.ts:668
	// return this.handoffStatusBox(pk).value;
	bytec 11 //  "hos"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.handoffStatusBox(pk).value
	assert
	extract 2 0

	// set the subroutine return value
	frame_bury 0
	retsub

// getHandoffConfirmedAt(uint64,uint64)uint64
*abi_route_getHandoffConfirmedAt:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// handoffIndex: uint64
	txna ApplicationArgs 2
	btoi

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getHandoffConfirmedAt(uint64,uint64)uint64
	callsub getHandoffConfirmedAt
	itob
	concat
	log
	intc 0 // 1
	return

// getHandoffConfirmedAt(batchAsaId: BatchAsaId, handoffIndex: uint64): uint64
getHandoffConfirmedAt:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:673
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:674
	// this.assertHandoffIndex(batchAsaId, handoffIndex)
	frame_dig -2 // handoffIndex: uint64
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertHandoffIndex

	// contracts/contractSupply/contract.algo.ts:675
	// pk = batchAsaId * 10000 + handoffIndex
	frame_dig -1 // batchAsaId: BatchAsaId
	intc 2 // 10000
	*
	frame_dig -2 // handoffIndex: uint64
	+
	frame_bury 0 // pk: uint64

	// contracts/contractSupply/contract.algo.ts:676
	// return this.handoffConfirmedAtBox(pk).value;
	bytec 23 //  "hca"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.handoffConfirmedAtBox(pk).value
	assert
	btoi

	// set the subroutine return value
	frame_bury 0
	retsub

// getHandoffPhotoHashes(uint64,uint64)string
*abi_route_getHandoffPhotoHashes:
	// The ABI return prefix
	bytec 0 // 0x151f7c75

	// handoffIndex: uint64
	txna ApplicationArgs 2
	btoi

	// batchAsaId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getHandoffPhotoHashes(uint64,uint64)string
	callsub getHandoffPhotoHashes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// getHandoffPhotoHashes(batchAsaId: BatchAsaId, handoffIndex: uint64): string
getHandoffPhotoHashes:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 1 // 0x

	// contracts/contractSupply/contract.algo.ts:681
	// this.assertBatchExists(batchAsaId)
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertBatchExists

	// contracts/contractSupply/contract.algo.ts:682
	// this.assertHandoffIndex(batchAsaId, handoffIndex)
	frame_dig -2 // handoffIndex: uint64
	frame_dig -1 // batchAsaId: BatchAsaId
	callsub assertHandoffIndex

	// contracts/contractSupply/contract.algo.ts:683
	// pk = batchAsaId * 10000 + handoffIndex
	frame_dig -1 // batchAsaId: BatchAsaId
	intc 2 // 10000
	*
	frame_dig -2 // handoffIndex: uint64
	+
	frame_bury 0 // pk: uint64

	// contracts/contractSupply/contract.algo.ts:684
	// return this.handoffPhotoHashesBox(pk).value;
	bytec 47 //  "hph"
	frame_dig 0 // pk: uint64
	itob
	concat
	box_get

	// box value does not exist: this.handoffPhotoHashesBox(pk).value
	assert
	extract 2 0

	// set the subroutine return value
	frame_bury 0
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x17866912 // method "setAdmin(address)void"
	pushbytes 0x44dd4277 // method "createBatch(string,uint64,string,string,string,string,uint64)uint64"
	pushbytes 0xa89dc211 // method "logCheckpoint(uint64,string,string,uint64,uint64,string,string,string,uint64)void"
	pushbytes 0x19890f8b // method "initiateHandoff(uint64,string,string,string,string)void"
	pushbytes 0x5274508a // method "confirmHandoff(uint64,uint64,uint64)void"
	pushbytes 0xf74fcd8d // method "mintBatchAsa(uint64,byte[])uint64"
	pushbytes 0x4f9f263d // method "storeVerification(uint64,string,uint64,string,string)void"
	pushbytes 0x9c2aa9dc // method "updateCarbonScore(uint64,uint64,uint64,uint64,string,uint64)void"
	pushbytes 0x8b439311 // method "updateFarmerReputation(string,uint64,uint64,uint64,string,uint64,uint64,uint64)void"
	pushbytes 0xfbb66dc3 // method "recordFarmerPayment(string,uint64,uint64,string,string,uint64)void"
	pushbytes 0x66ce0be4 // method "getVerification(uint64)string"
	pushbytes 0xd00fdd9c // method "getTotalVerifications()uint64"
	pushbytes 0x62603280 // method "getTotalBatches()uint64"
	pushbytes 0x37e34533 // method "getTotalPayments()uint64"
	pushbytes 0x7a3e10b9 // method "getVerificationConfidence(uint64)uint64"
	pushbytes 0xaf3af3f4 // method "getVerificationReason(uint64)string"
	pushbytes 0x749b27fb // method "getVerificationVerifierAddr(uint64)string"
	pushbytes 0xd43347f7 // method "getVerificationTimestamp(uint64)uint64"
	pushbytes 0xb27eab55 // method "getCarbonScore(uint64)uint64"
	pushbytes 0xc03c09b5 // method "getCarbonCredits(uint64)uint64"
	pushbytes 0x4c83a7ea // method "getCarbonDistance(uint64)uint64"
	pushbytes 0x1c8968e9 // method "getCarbonTransportMethod(uint64)string"
	pushbytes 0x38b9674e // method "getCarbonCalculatedAt(uint64)uint64"
	pushbytes 0x07d46e41 // method "getFarmerTotalBatches(string)uint64"
	pushbytes 0x13b3e2ad // method "getFarmerVerifiedCount(string)uint64"
	pushbytes 0x111c7882 // method "getFarmerFlaggedCount(string)uint64"
	pushbytes 0xbecc8729 // method "getFarmerTier(string)string"
	pushbytes 0x8f139afe // method "getFarmerCarbonCreditsTotal(string)uint64"
	pushbytes 0xd3a79430 // method "getFarmerPaymentsTotal(string)uint64"
	pushbytes 0xa8ace79d // method "getFarmerLastUpdated(string)uint64"
	pushbytes 0xfc19bf71 // method "getPaymentFarmerAddr(uint64)string"
	pushbytes 0x093c63dc // method "getPaymentBatchId(uint64)uint64"
	pushbytes 0x52c03d78 // method "getPaymentAmount(uint64)uint64"
	pushbytes 0xce1e14be // method "getPaymentCurrency(uint64)string"
	pushbytes 0xd77cd42b // method "getPaymentTxId(uint64)string"
	pushbytes 0xf79f0f0d // method "getPaymentTimestamp(uint64)uint64"
	pushbytes 0x31c4599d // method "getBatch(uint64)string"
	pushbytes 0xb45d012b // method "hasBatch(uint64)bool"
	pushbytes 0x91ceaeb8 // method "getCheckpoint(uint64,uint64)string"
	pushbytes 0x0284db29 // method "getCheckpointCount(uint64)uint64"
	pushbytes 0xcd5e25a5 // method "getHandoff(uint64,uint64)string"
	pushbytes 0xd27cbec7 // method "hasHandoff(uint64,uint64)bool"
	pushbytes 0x3424d97c // method "getHandoffCount(uint64)uint64"
	pushbytes 0xf0e9485f // method "getBatchWeight(uint64)uint64"
	pushbytes 0xe297e1c2 // method "getBatchCropType(uint64)string"
	pushbytes 0x8968e179 // method "getBatchFarmGps(uint64)string"
	pushbytes 0x8c441942 // method "getBatchFarmingPractices(uint64)string"
	pushbytes 0x30f27c2f // method "getBatchOrganicCertId(uint64)string"
	pushbytes 0xef22cb4c // method "getBatchFarmerAddr(uint64)string"
	pushbytes 0x43775cf5 // method "getBatchCreatedAt(uint64)uint64"
	pushbytes 0xc40fe65d // method "getBatchAsaId(uint64)uint64"
	pushbytes 0x21180b10 // method "getCheckpointTemperature(uint64,uint64)uint64"
	pushbytes 0x964bf0db // method "getCheckpointHumidity(uint64,uint64)uint64"
	pushbytes 0x5f385ab8 // method "getCheckpointGps(uint64,uint64)string"
	pushbytes 0x4d667f4c // method "getCheckpointHandlerType(uint64,uint64)string"
	pushbytes 0x957aa8f3 // method "getCheckpointNotes(uint64,uint64)string"
	pushbytes 0xb9ae5364 // method "getCheckpointPhotoHash(uint64,uint64)string"
	pushbytes 0x05f0d579 // method "getCheckpointTimestamp(uint64,uint64)uint64"
	pushbytes 0x4ba50a27 // method "getHandoffFromAddr(uint64,uint64)string"
	pushbytes 0x37db2ef6 // method "getHandoffToAddr(uint64,uint64)string"
	pushbytes 0x3bd4290f // method "getHandoffType(uint64,uint64)string"
	pushbytes 0xbc4a8cdd // method "getHandoffStatus(uint64,uint64)string"
	pushbytes 0x28b45eee // method "getHandoffConfirmedAt(uint64,uint64)uint64"
	pushbytes 0x03ad66e8 // method "getHandoffPhotoHashes(uint64,uint64)string"
	txna ApplicationArgs 0
	match *abi_route_setAdmin *abi_route_createBatch *abi_route_logCheckpoint *abi_route_initiateHandoff *abi_route_confirmHandoff *abi_route_mintBatchAsa *abi_route_storeVerification *abi_route_updateCarbonScore *abi_route_updateFarmerReputation *abi_route_recordFarmerPayment *abi_route_getVerification *abi_route_getTotalVerifications *abi_route_getTotalBatches *abi_route_getTotalPayments *abi_route_getVerificationConfidence *abi_route_getVerificationReason *abi_route_getVerificationVerifierAddr *abi_route_getVerificationTimestamp *abi_route_getCarbonScore *abi_route_getCarbonCredits *abi_route_getCarbonDistance *abi_route_getCarbonTransportMethod *abi_route_getCarbonCalculatedAt *abi_route_getFarmerTotalBatches *abi_route_getFarmerVerifiedCount *abi_route_getFarmerFlaggedCount *abi_route_getFarmerTier *abi_route_getFarmerCarbonCreditsTotal *abi_route_getFarmerPaymentsTotal *abi_route_getFarmerLastUpdated *abi_route_getPaymentFarmerAddr *abi_route_getPaymentBatchId *abi_route_getPaymentAmount *abi_route_getPaymentCurrency *abi_route_getPaymentTxId *abi_route_getPaymentTimestamp *abi_route_getBatch *abi_route_hasBatch *abi_route_getCheckpoint *abi_route_getCheckpointCount *abi_route_getHandoff *abi_route_hasHandoff *abi_route_getHandoffCount *abi_route_getBatchWeight *abi_route_getBatchCropType *abi_route_getBatchFarmGps *abi_route_getBatchFarmingPractices *abi_route_getBatchOrganicCertId *abi_route_getBatchFarmerAddr *abi_route_getBatchCreatedAt *abi_route_getBatchAsaId *abi_route_getCheckpointTemperature *abi_route_getCheckpointHumidity *abi_route_getCheckpointGps *abi_route_getCheckpointHandlerType *abi_route_getCheckpointNotes *abi_route_getCheckpointPhotoHash *abi_route_getCheckpointTimestamp *abi_route_getHandoffFromAddr *abi_route_getHandoffToAddr *abi_route_getHandoffType *abi_route_getHandoffStatus *abi_route_getHandoffConfirmedAt *abi_route_getHandoffPhotoHashes

	// this contract does not implement the given ABI method for call NoOp
	err